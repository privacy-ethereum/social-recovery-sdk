{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"9638449206552121918","abi":{"parameters":[{"name":"data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":900,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"email","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"public"},{"name":"intent_hash","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2707472466662157409":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5624732299715428208":{"error_kind":"string","string":"incorrect value for claim"},"5814456561209054291":{"error_kind":"string","string":"Field failed to decompose into specified 30 limbs"},"5899151545213940874":{"error_kind":"string","string":"Field failed to decompose into specified 31 limbs"},"7287311796025951795":{"error_kind":"string","string":"Field failed to decompose into specified 1 limbs"},"7688826323084302732":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"8784292831194001448":{"error_kind":"string","string":"data length is too long"},"9348174407804301993":{"error_kind":"string","string":"intent_hash cannot be zero"},"9752593157046867219":{"error_kind":"string","string":"haystack length of size 0 not supported"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"12087256528359734805":{"error_kind":"string","string":"needle length of size 0 not supported"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13805293347880442112":{"error_kind":"string","string":"Email content mismatch"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17568106868988118403":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"17592221717757552052":{"error_kind":"string","string":"Email length mismatch"},"18287357528562917927":{"error_kind":"string","string":"Field failed to decompose into specified 15 limbs"}}},"bytecode":"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","debug_symbols":"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gxteMd9ezLcX8+214RXz7cV8ezHfXhteMd9ezLfXhlfMtxfz7cV8e214xXx7Md9ezLfXhlfMtxfz7bXZXzHfXsy3F/PttdlfMd9ezLcX8+212V8x317Mt9f+zuur/Z3XV/s7r6/2d15fMd9enN9enN9enN9ezLcX57cX57cX57fX/vqDxfntxfnttS/rXta9rHv5fC/rXta9rJt8vsm6ybrJ9ypZN1k3WTf5fJN1k3WLdYvPt1i3WLf4XhXrFusW6xbfq2LdZt1m3eZ71azbrNt8r77+YO2vP1i7+V4136vhewWv9tcfrP31B2t//cHaX3+wmG8v5tuL89uL89uL+fZivr04v704v72Yb6/z9QeL89uL+fZivr04v704v72Yby/m24vz24vz24v59jrBul9/sA68Yr69mG8v5tvrwCvm24v59mK+vQ68Yr69mG+vA6+Yby/m24v59jrwivn2Yr69mG+vA6+Yby/m2+t8/cE6X3+wztcfrPP1B+t8/cE6X3+wztcfrPP1B+t8/cE6X3+wztcfrEM9yHx7Md9ezLfXoR5kvr2Yby/m2+vw/Ir59mK+vQ714EnWhVec316HevAk68Irzm+vU6xbrAuvDs+vDs+vDrw68Orw/Orw/OrAqwOvDs+vTrMuvDrUg4fnV6dZt/n3Sz14eH51hnWHf788vzrDugM3vv5gna8/WOfrD9b5+oN1vv5g3a8/WPfrD9b9+oN1v/5g3a8/WPfrD9Zlf3XhFee3F+e312V/deEV57cX57fXZX914RXnt9dlf3XhFee3F+e312V/deEV57cX57fXZX914RXnt9dlf3XhFee3F+e312V/deEV57cX57fXZX914RXnt9fl+dXl+dXleftlf3V5fnV5fnV53n7ZX12eX12et9+vP1j36w/W/fqDdb/+YN2vP1j36w/W/fqDdb/+YN2vP1j36w/W/fqDdb/+YF3qwQuvLry68OpSD154deHVhVeX51cXXl14dakHL7y68OrCq0s9eOHVhVcXXl2et194deHVpR688OrCqwuvLvXghVcXXl14dXl+deHVhVec316c316X/dVlf8X57cX57ZXsr5L9Fee3V1IPJvurpD+Y9AeT/mDSH0z6g0l/MOkPJv3BpD+Y9AeT/iDntxfnt1fCq4RXnN9enN9eCa8SXnF+eyW8SnjF+e3F+e2V8Crh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9Qdnf/3B2V9/cPbXH5z99Qdnf/3B2V9/cDb14IZXG15teLWpBze82vBqw6sd/L7wasOrTT244dWGVxteberBDa82vNrwam/WhVcbXm3qwQ2vNrza8GpTD254teHVhlf7sC682vCK89uH89tns7/a7K84v304v302+6vN/orz22dTD272V/vrD87++oOzv/7g7K8/OPvrD87++oOzv/7g7K8/OPvrD87++oOzv/7gcH77cH77bHi14RXntw/nt8+GVxtecX77bHi14RXntw/nt8+GVxtecX77cH77bHi14RXnt8+GVxte7WZdeLXh1YZXe1gXXm14teHVHtaFVxtecX77nO95+xz2V4f9Fee3z/met89hf3XYX53vefuc73n7HPZX5+sPzvn6g3O+/uCcrz845+sPzvn6g3O+/uCcrz845+sPzvn6g3O+/uBwfvsceHXg1YFXnN8+B14deHXg1eH51YFXB15xfvsceHXg1YFXnN8+B14deHXg1eH51YFXB16dw7rw6sCrA6/OYV14deDVgVfnsi68OvCK89vn8PzqsL867K84v30Oz68O+6vD/uok6/L86rC/Ol9/cM7XH5zz9QfnfP3BOV9/cM7XH5zz9QfnfP3BOV9/cM7XH5zz9QeH89vnwKsDrw684vz2OfDqwKsDr07z+8KrA684v30OvDrw6sArzm+fA68OvDrw6gzrwqsDr86wLry68OrCq/v1B+fCqwuvLry6X39wLry68Irz2+fyvP2yv7rsrzi/fS7P2y/7q8v+6vK8/fK8/bK/ul9/cO7XH5z79Qfnfv3BuV9/cO7XH5z79Qfnfv3BuV9/cO7XH5z79QeH89vnwqsLry684vz2ufDqwqsLry7P2y+8uvCK89vnwqsLry684vz2ufDqwqsLr+5lXXh14dW9rAuvLry68Ope1oVXF15deHWTdeHVhVec3z43WZf91WV/xfntc5N12V9d9le3WLdYl/3V/fqDc7/+4NyvPzj36w/O/fqDc7/+4NyvPzj36w/O/fqDc7/+4PzNt7+v+X3h1YVXF15xfvtceHXh1YVXd/h94dWFV5zfPhdeXXiV8Irz2yfhVcKrhFf53Y8zCa8SXiX9wYRXCa8SXiX9wYRXCa8SXiX9wYRXCa84v32S/mCyv0r2V5zfPkl/MNlfJfurpD+Y9AeT/dXffPv59zp4vXi9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kolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXilolbJm6ZuGXikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGXilYlXJl6ZeGVi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GXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLGMOZYxxzLmWMYcy5hjGXMsY45lzLEMOZb1kGP5EaH4z8GP+M/BjziK6/9NKkrRCh2E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HUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseS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SsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKx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ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1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dCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQs/ztYgZmoY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY3k6lqdjeTqWp2N5OpanY/nfwQrMxDQTdSxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCxPx/J0LE/H8nQsT8fydCzvn2Ppn0N7+Kng/Ryeh8/Devip4Pu/wz/H8nsID+mhPLSH8fA8fB7WgxWEFYQVhBWEFYQVhBWEFYQVhBWEFaQVpBWkFaQVpBWkFaQVpBWkFaQVlBWUFZQVlBWUFZQVlBWUFZQVlBW0FbQVtBW0FbQVtBW0FbQVtBW0FYwVjBWMFYwVjBWMFYwVjBWMFYwVPCt4VvCs4FnBs4JnBc8KnhU8K3hW8FnBZwWfFXxW8FnBZwWfFXxW8FnBZwVrBWsFawVrBWsFawVrBWsFawVrBWcFZwVnBWcFZwVnBWcFZwVnBWbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGbimYlnJp6ZeGTi94dM/P6Qid8fMvH7QyZ+f8jE7w+Z+P0hE78/ZOL3h0z8/vyxgrCCsIKwgrCCsIKwgrCCsIKwgrCCtIK0grSCtIK0grSCtIK0grSCtIKygrKCsoKygrKCsoKygrKCsoKygraCtoK2graCtoK2graCtoK2graCsYKxgrGCsYKxgrGCsYKxgrGCsYJnBc8KnhU8K3hW8KzgWcGzgmcFzwo+K/is4LOCzwo+K/is4LOCzwo+K/isYK1grWCtYK1grWCtYK1grWCtYK3grOCs4KzgrOCs4KzgrOCs4KzATAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTAwzMczEMBPDTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTEwzMc3ENBPTTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTCwzsczEMhPLTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTGwzsc3ENhPbTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTBwzcczEMRPHTHxm4jMTn5n4zMRnJj4z8ZmJz0x8ZuIzE5+Z+MzEZyY+M/GZic9MfGbiMxOfmfjMxGcmPjPxmYnPTHxm4jMTn5n4zMRnJj4z8ZmJz0x8ZuIzE5+Z+MzEZyY+M/GZic9MfGbiMxOfmfjMxGcmPjPx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QxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTSxNLE0sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sTWxNbE1sT+4+JP2+d/5j4uxgW02JZbIubIG8RFmnxTrBft2j+5DHxKYbF5HceE58/2RYmuCZ+fscEj4lPYYJr4vM70wSPiU9hgmvi53dMMO2DaYJpH0wTLPtgmWDZB8sEyz5YJlj2wTLBsg+WCbZ9sE2w7YNtgm0fbBNs+2CbYNsH2wTHPjgmOPbBMcGxD44Jjn1wTHDsg2OCsA/CBGEfhAnCPggThH0QJgj7IEyQ9kGaIO2DNEHaB2mCtA/SBGkfpAnKPigTlH1QJij7oExQ9kGZoOyDMkHbB22Ctg/aBG0ftAnaPmgTtH3QJHjusdzfee6xfP5kWiyL7e8c/yQs0qL8HRNo4tDEoYnPPZbdt9gWxyIs0uKd4MQtmuKa+CmGxTtBPMW6xd9+/d3/+ce//us//tNf/uV//91/+38/5f/8r3/75//813//t6f8z//7H58/+ae//utf/vKv/+sf/uOv//7P//I//uuv//IPf/n3f/79Z3/3ev7x33+6pn/99EL9/c//Y/3UPxvAXz9bsJ9q3D/O8evnH/H7fxj3518//0PNv/9pf3xamTt+zThPG+f1K16fFuZPg3P15/fnXr/mPr9/e34z/Lz+/DV+XgY+vz9W/Rq7vhl+3rX+/HHUN8P5nfnnreDvVtafDOP8NL3208qa9Wutbytzv34y7jFI8v75/N3K/rSyft5o/Fo//37/0x8/z/7ZGX1aWT9v6H7+eOxPK7/fX//6/QL3dyvn00rtnz5aTxOxf+W3Q/P8qtfnl2v8qvX7F+P3L/7+2fkav+bN+P6r90/E1+v3j+TnR37+XeOvn3/b9/mRnwP4r58z9LfJn+GpOzr15++01k/oMz9/p5/IHd9I6+d176+ff5w/f6d5fv3+nPrv//a3v/393/4/","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_vectors() {\n        let vector_1 = &[0, 1, 2, 3];\n        let vector_2 = &[0, 1, 2];\n        assert(!vector_1.eq(vector_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_vectors() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a built-in vector except that it\n/// is bounded with a maximum possible length. `BoundedVec` is also not\n/// subject to the same restrictions vectors are (notably, nested vectors are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over vectors when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given vector to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_vector(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_vector(&mut self, vector: [T]) {\n        let new_len = self.len + vector.len();\n        assert(new_len <= MaxLen, \"extend_from_vector out of bounds\");\n        for i in 0..vector.len() {\n            self.storage[self.len + i] = vector[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_vector(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_vector out of bounds\")]\n        fn extend_vector_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_vector(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_vector(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use jwt::JWT;\nuse poseidon::poseidon2::Poseidon2;\n\nglobal MAX_DATA_LENGTH: u32 = 900;      // JWT signed data (header.payload) max length\nglobal MAX_EMAIL_LENGTH: u32 = 128;     // max email length in bytes\nglobal PACKED_EMAIL_FIELDS: u32 = 5;    // ceil(128/31) Fields needed for email\nglobal BYTES_PER_FIELD: u32 = 31;       // 31 bytes safely fit in a Field (~254 bits)\n\n/// Packs bytes into Field elements (31 bytes per Field, big-endian).\nfn pack_bytes_to_fields<let N: u32, let M: u32>(bytes: BoundedVec<u8, N>) -> [Field; M] {\n    let mut result: [Field; M] = [0; M];\n    let len = bytes.len();\n\n    for field_idx in 0..M {\n        let mut field_value: Field = 0;\n        let start_byte = field_idx * BYTES_PER_FIELD;\n\n        for byte_offset in 0..BYTES_PER_FIELD {\n            let byte_idx = start_byte + byte_offset;\n            if byte_idx < len {\n                field_value = field_value * 256 + bytes.get(byte_idx) as Field;\n            }\n        }\n        result[field_idx] = field_value;\n    }\n\n    result\n}\n\n/// Verifies a Google JWT and outputs commitment = Poseidon2(email_hash, salt).\n///\n/// # Public Inputs\n/// - `pubkey_modulus_limbs`: RSA public key modulus (identifies Google signing key)\n/// - `intent_hash`: Hash of RecoveryIntent (binds proof to specific recovery session)\n///\n/// # Returns\n/// - `commitment`: Poseidon2(email_hash, salt) identifying the guardian\nfn main(\n    // Private inputs\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    base64_decode_offset: u32,\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    email: BoundedVec<u8, MAX_EMAIL_LENGTH>,\n    salt: Field,\n    // Public inputs\n    pubkey_modulus_limbs: pub [u128; 18],\n    intent_hash: pub Field,\n) -> pub Field {\n    // Dummy constraint for intent_hash public input\n    assert(intent_hash != 0, \"intent_hash cannot be zero\");\n\n    // Initialize and verify JWT signature\n    let jwt: JWT<MAX_DATA_LENGTH> = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n    jwt.verify();\n\n    // Verify email is verified by Google\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n\n    // Extract and verify email matches provided email\n    let jwt_email: BoundedVec<u8, MAX_EMAIL_LENGTH> = jwt.get_claim_string(\"email\".as_bytes());\n    assert(jwt_email.len() == email.len(), \"Email length mismatch\");\n    for i in 0..MAX_EMAIL_LENGTH {\n        if i < email.len() {\n            assert(jwt_email.get(i) == email.get(i), \"Email content mismatch\");\n        }\n    }\n\n    // Pack email bytes into Field elements (31 bytes per Field)\n    let packed_email: [Field; PACKED_EMAIL_FIELDS] = pack_bytes_to_fields(email);\n\n    // email_hash = Poseidon2(packed_email_fields, email_len)\n    let email_hash = Poseidon2::hash(\n        [packed_email[0], packed_email[1], packed_email[2], packed_email[3], packed_email[4], email.len() as Field],\n        6,\n    );\n\n    // commitment = Poseidon2(email_hash, salt)\n    // Note: intent_hash is a public input that binds this proof to a specific recovery session.\n    // The on-chain verifier checks that intent_hash matches the current session's RecoveryIntent.\n    Poseidon2::hash([email_hash, salt], 2)\n}\n\n#[test]\nfn test_pack_bytes_to_fields() {\n    let mut bytes: BoundedVec<u8, 128> = BoundedVec::new();\n    bytes.push(0x61); // 'a'\n    bytes.push(0x62); // 'b'\n    bytes.push(0x63); // 'c'\n\n    let packed: [Field; 5] = pack_bytes_to_fields(bytes);\n\n    // \"abc\" big-endian: 0x61 * 256^2 + 0x62 * 256 + 0x63 = 6382179\n    assert(packed[0] == 6382179);\n    assert(packed[1] == 0);\n}\n\n#[test]\nfn test_commitment() {\n    let mut email: BoundedVec<u8, 128> = BoundedVec::new();\n    let email_bytes: [u8; 14] = [97, 108, 105, 99, 101, 64, 116, 101, 115, 116, 46, 99, 111, 109]; // alice@test.com\n    for i in 0..14 {\n        email.push(email_bytes[i]);\n    }\n\n    let packed: [Field; 5] = pack_bytes_to_fields(email);\n    let email_hash = Poseidon2::hash([packed[0], packed[1], packed[2], packed[3], packed[4], 14], 6);\n\n    let c1 = Poseidon2::hash([email_hash, 123], 2);\n    let c2 = Poseidon2::hash([email_hash, 123], 2);\n    let c3 = Poseidon2::hash([email_hash, 456], 2);\n\n    assert(c1 == c2); // same inputs -> same commitment\n    assert(c1 != c3); // different salt -> different commitment\n}\n\n#[test]\nfn test_multi_field_packing_and_uniqueness() {\n    // Test email that spans multiple fields (>31 bytes)\n    // \"verylongemailaddress1234@example.com\" = 36 bytes (spans 2 fields)\n    let mut long_email: BoundedVec<u8, 128> = BoundedVec::new();\n    let long_email_bytes: [u8; 36] = [\n        118, 101, 114, 121, 108, 111, 110, 103, 101, 109, 97, 105, 108, 97, 100, 100,  // \"verylongemailadd\"\n        114, 101, 115, 115, 49, 50, 51, 52, 64, 101, 120, 97, 109, 112, 108, 101,      // \"ress1234@example\"\n        46, 99, 111, 109                                                                // \".com\"\n    ];\n    for i in 0..36 {\n        long_email.push(long_email_bytes[i]);\n    }\n\n    let packed_long: [Field; 5] = pack_bytes_to_fields(long_email);\n\n    // First field should contain first 31 bytes, second field should contain remaining 5 bytes\n    assert(packed_long[0] != 0); // First field has data\n    assert(packed_long[1] != 0); // Second field has data (bytes 32-36)\n    assert(packed_long[2] == 0); // Third field is empty\n\n    // Compute commitment for long email\n    let long_email_hash = Poseidon2::hash(\n        [packed_long[0], packed_long[1], packed_long[2], packed_long[3], packed_long[4], 36],\n        6,\n    );\n    let long_commitment = Poseidon2::hash([long_email_hash, 999], 2);\n\n    // Compute commitment for short email (alice@test.com)\n    let mut short_email: BoundedVec<u8, 128> = BoundedVec::new();\n    let short_email_bytes: [u8; 14] = [97, 108, 105, 99, 101, 64, 116, 101, 115, 116, 46, 99, 111, 109];\n    for i in 0..14 {\n        short_email.push(short_email_bytes[i]);\n    }\n    let packed_short: [Field; 5] = pack_bytes_to_fields(short_email);\n    let short_email_hash = Poseidon2::hash(\n        [packed_short[0], packed_short[1], packed_short[2], packed_short[3], packed_short[4], 14],\n        6,\n    );\n    let short_commitment = Poseidon2::hash([short_email_hash, 999], 2);\n\n    // Different emails with same salt must produce different commitments\n    assert(long_commitment != short_commitment);\n\n    // Same long email with same salt must produce same commitment (deterministic)\n    let long_commitment_2 = Poseidon2::hash([long_email_hash, 999], 2);\n    assert(long_commitment == long_commitment_2);\n}\n\n#[test(should_fail_with = \"intent_hash cannot be zero\")]\nfn test_intent_hash_cannot_be_zero() {\n    // This test verifies that intent_hash = 0 is rejected\n    let intent_hash: Field = 0;\n    assert(intent_hash != 0, \"intent_hash cannot be zero\");\n}\n","path":"/Users/magamedrasul/projects/pse/social-recovery-sdk/circuits/zkjwt/src/main.nr"},"52":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/magamedrasul/nargo/github.com/zkemail/noir-jwt/v0.5.1/src/lib.nr"},"55":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"},"56":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"},"95":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"},"96":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"},"98":{"source":"use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"},"99":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"},"100":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"},"102":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"},"103":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"},"110":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"},"139":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr"},"142":{"source":"use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n","path":"/Users/magamedrasul/nargo/github.com/zkpassport/noir_rsa/v0.9.1/src/rsa.nr"},"158":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"},"159":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"},"167":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/magamedrasul/nargo/github.com/noir-lang/poseidon/v0.2.0/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}